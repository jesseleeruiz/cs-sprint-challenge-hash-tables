Overview
    - Provide key/value storage with constant time for insertion, deletion and search.

Hashing functions
    - A hash function is a function where the input is any data, and the output is a number.

    - A hash function must be consistent(deterministic). Every time it receives the 
    same input it must return the same output.
    If it's not deterministic, it is not a hash function.

    - Different input data should return different numbers.

    - A hash function must return numbers that are within a specific range.

    - The reason the hash function should return different numbers is to minimize
    collisions.
    When a hash function maps each different input data to a different number, 
    it is called a perfect hash function.
    In practice, unless we know all the possible data inputs, we can't create a 
    perfect hash funciton.

    - When you combine a hash function with an array, you get a data structure called
    a hash table (aka hash map or dictionary).

Collision resolution
    - To mitigate collisions, you can allow each slot to hold a reference to a
    collection (or chain) of items.
    The advantage of doing this is that, on average, each slot is likely to have
    very few items, so even when we take collisions into account search, insertion
    and deletion operations are still quite efficient.

Performance of basic hash table operations
    - Once we take collisions into account our worst case performance for search, insertion, 
    and deletion operations take linear time.
    The worst case would be if every hash table entry were placed inside the linked list that was
    referenced by a single index.
    However, the average case is still constant time. So, if we handle collisions well and we have
    a hashing function that does an excellent job of spreading the data evenly across the hash table,
    hash tables are very performant data structures.

Load factor
    - To avoid collisions, a proper hash function and maintaining a low load factor is crucial.

    - The load factor of a hash table is number of items stored in the HT divided by the number
    of slots.

    - HT use an array for storage, so the load factor would be the number of occupied slots divided
    by the length of the array.
        - So, an array length of 10 with three items in it has a load factor of 0.3

    - If you use linear probing for collision resolution, then the max LF is 1.
    - If you use chaining for CR, then the LF can be greater than 1.

    - As the LF of your HT increase, so does the likelihood of a collision, which reduces the 
    performance of your HT. 
    Therefore, you need to monitor the LF and resize your HT when the LF gets too large.
    The general rule of thumb is to resize your HT when you LF is greater that 0.7

    - You can see that resizing is an expensive operation, so you donâ€™t want to resize too often. 
    However, when we average it out, hash tables are constant time (O(1)) even with resizing.

    - The load factor can also be too small. If the hash table is too large for the data that it is 
    storing, then memory is being wasted. 
    So, in addition to resizing, when the load factor gets too high, you should also resize when 
    the load factor gets too low.

    - One way to know when to resize your hash table is to compute the load factor whenever an 
    item is inserted or deleted into the hash table. 
    If the load factor is too high or too low, then you need to resize.

Automatic resizing


Various use cases for hash tables
    - Lookups
        - HT are perfect for when you need to map from one thing to another, usually to be able
        to look something up.
        - EX: Digital Phone Book, DNS Resolution, student records, library system

    - Duplicate Prevention
        - Storing Users, a voting system

    - Caching
        - Servers use HT to cache the data and info they are serving down to clients.

        - The server runs the calculation the first time and then cahces that info to serve all the 
        other clients.

        - If the server gets updated info, you would then want the server to rerun the computations
        and cache the new result.

        - The HT, in this case, maps the URL the client requests to the page data it needs to send
        back to the client.


